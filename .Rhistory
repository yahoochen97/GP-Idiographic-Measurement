}
if( MODEL_NAME=="graded"){
tmp = exp(tmp)/sum(exp(tmp))
ps = c(1-tmp[1])
for(c in 1:(C-2)){
ps = c(ps, tmp[c]-tmp[c+1])
}
ps = as.vector(c(ps, tmp[C-1]))
} else if (MODEL_NAME=="gpcm"){
tmp = c(0, tmp)
ps = as.vector(exp(tmp)/sum(exp(tmp)))
} else if (MODEL_NAME=="sequential"){
tmp = plogis(tmp)
ps = c(tmp,1)*c(1,cumprod(1-tmp))
}
pred_y = which.max(ps)
if(!is.na(test_data[i,h,j])){
test_acc = c(test_acc, pred_y==test_data[i,h,j])
if(ps[test_data[i,h,j]]<=-1e-6){
print(paste(i,"_",h,"_",j,sep=""))
}
test_ll = c(test_ll, log(1e-6+ps[test_data[i,h,j]]))
}else{
train_acc = c(train_acc, pred_y==train_data[i,h,j])
if(ps[train_data[i,h,j]]<=-1e-6){
print(paste(i,"_",h,"_",j,sep=""))
}
train_ll = c(train_ll, log(1e-6+ps[train_data[i,h,j]]))
}
}
}
}
train_acc = mean(train_acc)
train_ll = mean(train_ll[!is.na(train_ll)])
test_acc = mean(test_acc)
test_ll = mean(test_ll[!is.na(test_ll)])
save(loadings, correlation_matrix, log_lik, BIC, thetas,train_acc, train_ll,test_acc, test_ll,
file=paste("./results/synthetic/", TYPE,"_", HYP, ".RData" , sep=""))
source('~/Documents/GitHub/GP-Idiographic-Measurement/utilities/simulation_MIRT.R', echo=TRUE)
EM_method
if(MODEL_NAME=="sequential"){
coefs = coef(mirt_fit, simplify = TRUE)$items
} else{
coefs = coef(mirt_fit, IRTpars = TRUE, simplify = TRUE)$items
}
if(UNI=="uni"){
loadings = matrix(as.vector(coefs[,1]))
} else{
loadings = matrix(as.vector(coefs[,1:RANK]), nrow=m)
}
correlation_matrix = loadings %*% t(loadings)
log_lik = mirt_fit@Fit$logLik
BIC = mirt_fit@Fit$BIC
if(UNI=="uni"){
thetas = array(fscores(mirt_fit), c(n,horizon))
} else{
thetas = array(as.vector(fscores(mirt_fit)), c(n,horizon, RANK))
}
fscores(mirt_fit)
EM_method = "MCEM"
SEED
mirt_fit <- mirt(data = data.frame(train_data),
model = factor_model,
itemtype = MODEL_NAME,
method = EM_method,
verbose = FALSE)
EM_method="SEM"
mirt_fit <- mirt(data = data.frame(train_data),
model = factor_model,
itemtype = MODEL_NAME,
method = EM_method,
verbose = FALSE)
EM_method
EM_method="MHRM"
mirt_fit <- mirt(data = data.frame(train_data),
model = factor_model,
itemtype = MODEL_NAME,
method = EM_method,
verbose = FALSE)
EM_method="EM"
mirt_fit <- mirt(data = data.frame(train_data),
model = factor_model,
itemtype = MODEL_NAME,
method = EM_method,
optimizer = "NR",
verbose = FALSE)
EM_method = "QMCEM"
mirt_fit <- mirt(data = data.frame(train_data),
model = factor_model,
itemtype = MODEL_NAME,
method = EM_method,
optimizer = "NR",
verbose = FALSE)
mirt_fit <- mirt(data = data.frame(train_data),
model = factor_model,
itemtype = MODEL_NAME,
method = EM_method,
optimizer = "nlminb",
verbose = FALSE)
if(MODEL_NAME=="sequential"){
coefs = coef(mirt_fit, simplify = TRUE)$items
} else{
coefs = coef(mirt_fit, IRTpars = TRUE, simplify = TRUE)$items
}
if(UNI=="uni"){
loadings = matrix(as.vector(coefs[,1]))
} else{
loadings = matrix(as.vector(coefs[,1:RANK]), nrow=m)
}
correlation_matrix = loadings %*% t(loadings)
log_lik = mirt_fit@Fit$logLik
BIC = mirt_fit@Fit$BIC
if(UNI=="uni"){
thetas = array(fscores(mirt_fit), c(n,horizon))
} else{
thetas = array(as.vector(fscores(mirt_fit)), c(n,horizon, RANK))
}
get_latent_f = function(as, theta, bs){
# set na as very extreme number
if(MODEL_NAME=="sequential"){
bs[is.na(bs)] = -1000
} else{
if(as>0){
bs[is.na(bs)] = 1000
} else{
bs[is.na(bs)] = -1000
}
}
# compute latent f
if(MODEL_NAME=="graded"){
f = as*(theta-bs)
} else if(MODEL_NAME=="gpcm"){
f = as*(theta-bs)
f = cumsum(f)
} else if(MODEL_NAME=="sequential"){
f = as*theta-bs
}
return(f)
}
# predict test observations and likelihood
train_acc = c()
train_ll = c()
test_acc = c()
test_ll = c()
dim(test_data) = c(n, horizon, m)
dim(train_data) = c(n, horizon, m)
for(i in 1:n){
for(j in 1:m){
for(h in 1:horizon){
if(UNI=="uni"){
# tmp = coefs[j]*(thetas[i,j]-coefs[j,(2):C])
tmp = get_latent_f(coefs[j],thetas[i,h],coefs[j,2:C])
} else{
tmp = 0
for(r in 1:RANK){
# tmp = tmp + coefs[j,r]*(thetas[i,j,r]-coefs[j,(RANK+1):(RANK+C-1)])
tmp = tmp + get_latent_f(coefs[j,r],thetas[i,h,r],coefs[j,(RANK+1):(RANK+C-1)])
}
}
if( MODEL_NAME=="graded"){
tmp = exp(tmp)/sum(exp(tmp))
ps = c(1-tmp[1])
for(c in 1:(C-2)){
ps = c(ps, tmp[c]-tmp[c+1])
}
ps = as.vector(c(ps, tmp[C-1]))
} else if (MODEL_NAME=="gpcm"){
tmp = c(0, tmp)
ps = as.vector(exp(tmp)/sum(exp(tmp)))
} else if (MODEL_NAME=="sequential"){
tmp = plogis(tmp)
ps = c(tmp,1)*c(1,cumprod(1-tmp))
}
pred_y = which.max(ps)
if(!is.na(test_data[i,h,j])){
test_acc = c(test_acc, pred_y==test_data[i,h,j])
if(ps[test_data[i,h,j]]<=-1e-6){
print(paste(i,"_",h,"_",j,sep=""))
}
test_ll = c(test_ll, log(1e-6+ps[test_data[i,h,j]]))
}else{
train_acc = c(train_acc, pred_y==train_data[i,h,j])
if(ps[train_data[i,h,j]]<=-1e-6){
print(paste(i,"_",h,"_",j,sep=""))
}
train_ll = c(train_ll, log(1e-6+ps[train_data[i,h,j]]))
}
}
}
}
train_acc = mean(train_acc)
train_ll = mean(train_ll[!is.na(train_ll)])
test_acc = mean(test_acc)
test_ll = mean(test_ll[!is.na(test_ll)])
save(loadings, correlation_matrix, log_lik, BIC, thetas,train_acc, train_ll,test_acc, test_ll,
file=paste("./results/synthetic/", TYPE,"_", HYP, ".RData" , sep=""))
source('~/Documents/GitHub/GP-Idiographic-Measurement/utilities/simulation_MIRT.R', echo=TRUE)
EM_method
source('~/Documents/GitHub/GP-Idiographic-Measurement/utilities/simulation_MIRT.R', echo=TRUE)
i
j
h
mirt_fit
coefs
coef(mirt_fit, IRTpars = TRUE, simplify = TRUE)$items
data.frame(train_data)
train_data[1,]
train_data[1]
train_data[,1]
dim(train_data) = c(n*horizon, m)
train_data[,1]
dim(test_data) = c(n*horizon, m)
dim(test_data) = c(n, horizon, m)
dim(train_data) = c(n, horizon, m)
coefs[j,2:C]
coefs[j,2:(ncol(coefs)-1)]
coefs[j,2:(ncol(coefs))]
ncol(coefs)
train_acc = c()
train_ll = c()
test_acc = c()
test_ll = c()
dim(test_data) = c(n, horizon, m)
dim(train_data) = c(n, horizon, m)
for(i in 1:n){
for(j in 1:m){
for(h in 1:horizon){
if(UNI=="uni"){
# tmp = coefs[j]*(thetas[i,j]-coefs[j,(2):C])
tmp = get_latent_f(coefs[j],thetas[i,h],coefs[j,2:ncol(coefs)])
} else{
tmp = 0
for(r in 1:RANK){
# tmp = tmp + coefs[j,r]*(thetas[i,j,r]-coefs[j,(RANK+1):(RANK+C-1)])
tmp = tmp + get_latent_f(coefs[j,r],thetas[i,h,r],coefs[j,(RANK+1):(RANK+C-1)])
}
}
if( MODEL_NAME=="graded"){
tmp = exp(tmp)/sum(exp(tmp))
ps = c(1-tmp[1])
for(c in 1:(C-2)){
ps = c(ps, tmp[c]-tmp[c+1])
}
ps = as.vector(c(ps, tmp[C-1]))
} else if (MODEL_NAME=="gpcm"){
tmp = c(0, tmp)
ps = as.vector(exp(tmp)/sum(exp(tmp)))
} else if (MODEL_NAME=="sequential"){
tmp = plogis(tmp)
ps = c(tmp,1)*c(1,cumprod(1-tmp))
}
pred_y = which.max(ps)
if(!is.na(test_data[i,h,j])){
test_acc = c(test_acc, pred_y==test_data[i,h,j])
if(ps[test_data[i,h,j]]<=-1e-6){
print(paste(i,"_",h,"_",j,sep=""))
}
test_ll = c(test_ll, log(1e-6+ps[test_data[i,h,j]]))
}else{
train_acc = c(train_acc, pred_y==train_data[i,h,j])
if(ps[train_data[i,h,j]]<=-1e-6){
print(paste(i,"_",h,"_",j,sep=""))
}
train_ll = c(train_ll, log(1e-6+ps[train_data[i,h,j]]))
}
}
}
}
train_acc = mean(train_acc)
train_ll = mean(train_ll[!is.na(train_ll)])
test_acc = mean(test_acc)
test_ll = mean(test_ll[!is.na(test_ll)])
save(loadings, correlation_matrix, log_lik, BIC, thetas,train_acc, train_ll,test_acc, test_ll,
file=paste("./results/synthetic/", TYPE,"_", HYP, ".RData" , sep=""))
i
j
h
tmp
MODEL_NAME
ps
ncol(coefs)
train_data[,j,]
unique(train_data[,j,])
unique(train_data[,j,])
unique(train_data[1,j,])
unique(train_data[1,j,])
unique(train_data[1,j,2])
unique(array(train_data[,j,],c(n*horizon,1)))
j
unique(array(train_data[,1,],c(n*horizon,1)))
coefs
coefs[j]
coefs[2]
array(train_data[,j,],c(n*horizon,1)
)
mirt_fit <- mirt(data = data.frame(train_data),
model = factor_model,
itemtype = MODEL_NAME,
method = EM_method,
optimizer = "nlminb",
verbose = FALSE)
SEED
if(MODEL_NAME=="sequential"){
coefs = coef(mirt_fit, simplify = TRUE)$items
} else{
coefs = coef(mirt_fit, IRTpars = TRUE, simplify = TRUE)$items
}
if(UNI=="uni"){
loadings = matrix(as.vector(coefs[,1]))
} else{
loadings = matrix(as.vector(coefs[,1:RANK]), nrow=m)
}
correlation_matrix = loadings %*% t(loadings)
log_lik = mirt_fit@Fit$logLik
BIC = mirt_fit@Fit$BIC
if(UNI=="uni"){
thetas = array(fscores(mirt_fit), c(n,horizon))
} else{
thetas = array(as.vector(fscores(mirt_fit)), c(n,horizon, RANK))
}
get_latent_f = function(as, theta, bs){
# set na as very extreme number
if(MODEL_NAME=="sequential"){
bs[is.na(bs)] = -1000
} else{
if(as>0){
bs[is.na(bs)] = 1000
} else{
bs[is.na(bs)] = -1000
}
}
# compute latent f
if(MODEL_NAME=="graded"){
f = as*(theta-bs)
} else if(MODEL_NAME=="gpcm"){
f = as*(theta-bs)
f = cumsum(f)
} else if(MODEL_NAME=="sequential"){
f = as*theta-bs
}
return(f)
}
train_acc = c()
train_ll = c()
test_acc = c()
test_ll = c()
dim(test_data) = c(n, horizon, m)
dim(train_data) = c(n, horizon, m)
for(i in 1:n){
for(j in 1:m){
for(h in 1:horizon){
if(UNI=="uni"){
# tmp = coefs[j]*(thetas[i,j]-coefs[j,(2):C])
tmp = get_latent_f(coefs[j],thetas[i,h],coefs[j,2:C])
} else{
tmp = 0
for(r in 1:RANK){
# tmp = tmp + coefs[j,r]*(thetas[i,j,r]-coefs[j,(RANK+1):(RANK+C-1)])
tmp = tmp + get_latent_f(coefs[j,r],thetas[i,h,r],coefs[j,(RANK+1):(RANK+C-1)])
}
}
if( MODEL_NAME=="graded"){
tmp = exp(tmp)/sum(exp(tmp))
ps = c(1-tmp[1])
for(c in 1:(C-2)){
ps = c(ps, tmp[c]-tmp[c+1])
}
ps = as.vector(c(ps, tmp[C-1]))
} else if (MODEL_NAME=="gpcm"){
tmp = c(0, tmp)
ps = as.vector(exp(tmp)/sum(exp(tmp)))
} else if (MODEL_NAME=="sequential"){
tmp = plogis(tmp)
ps = c(tmp,1)*c(1,cumprod(1-tmp))
}
pred_y = which.max(ps)
if(!is.na(test_data[i,h,j])){
test_acc = c(test_acc, pred_y==test_data[i,h,j])
if(ps[test_data[i,h,j]]<=-1e-6){
print(paste(i,"_",h,"_",j,sep=""))
}
test_ll = c(test_ll, log(1e-6+ps[test_data[i,h,j]]))
}else{
train_acc = c(train_acc, pred_y==train_data[i,h,j])
if(ps[train_data[i,h,j]]<=-1e-6){
print(paste(i,"_",h,"_",j,sep=""))
}
train_ll = c(train_ll, log(1e-6+ps[train_data[i,h,j]]))
}
}
}
}
train_acc = mean(train_acc)
train_ll = mean(train_ll[!is.na(train_ll)])
test_acc = mean(test_acc)
test_ll = mean(test_ll[!is.na(test_ll)])
save(loadings, correlation_matrix, log_lik, BIC, thetas,train_acc, train_ll,test_acc, test_ll,
file=paste("./results/synthetic/", TYPE,"_", HYP, ".RData" , sep=""))
i
j
h
coefs[j,2:C]
coefs[j,2:5]
coefs[j,2:4]
coefs[j,]
train_data[i,j,h]
train_data[i,j,]
train_data[,j,1]
train_data[,j,]
mirt_fit <- mirt(data = data.frame(train_data),
model = factor_model,
itemtype = MODEL_NAME,
method = "SEM",
verbose = FALSE)
if(MODEL_NAME=="sequential"){
coefs = coef(mirt_fit, simplify = TRUE)$items
} else{
coefs = coef(mirt_fit, IRTpars = TRUE, simplify = TRUE)$items
}
if(UNI=="uni"){
loadings = matrix(as.vector(coefs[,1]))
} else{
loadings = matrix(as.vector(coefs[,1:RANK]), nrow=m)
}
correlation_matrix = loadings %*% t(loadings)
log_lik = mirt_fit@Fit$logLik
BIC = mirt_fit@Fit$BIC
if(UNI=="uni"){
thetas = array(fscores(mirt_fit), c(n,horizon))
} else{
thetas = array(as.vector(fscores(mirt_fit)), c(n,horizon, RANK))
}
get_latent_f = function(as, theta, bs){
# set na as very extreme number
if(MODEL_NAME=="sequential"){
bs[is.na(bs)] = -1000
} else{
if(as>0){
bs[is.na(bs)] = 1000
} else{
bs[is.na(bs)] = -1000
}
}
# compute latent f
if(MODEL_NAME=="graded"){
f = as*(theta-bs)
} else if(MODEL_NAME=="gpcm"){
f = as*(theta-bs)
f = cumsum(f)
} else if(MODEL_NAME=="sequential"){
f = as*theta-bs
}
return(f)
}
train_acc = c()
train_ll = c()
test_acc = c()
test_ll = c()
dim(test_data) = c(n, horizon, m)
dim(train_data) = c(n, horizon, m)
for(i in 1:n){
for(j in 1:m){
for(h in 1:horizon){
if(UNI=="uni"){
# tmp = coefs[j]*(thetas[i,j]-coefs[j,(2):C])
tmp = get_latent_f(coefs[j],thetas[i,h],coefs[j,2:C])
} else{
tmp = 0
for(r in 1:RANK){
# tmp = tmp + coefs[j,r]*(thetas[i,j,r]-coefs[j,(RANK+1):(RANK+C-1)])
tmp = tmp + get_latent_f(coefs[j,r],thetas[i,h,r],coefs[j,(RANK+1):(RANK+C-1)])
}
}
if( MODEL_NAME=="graded"){
tmp = exp(tmp)/sum(exp(tmp))
ps = c(1-tmp[1])
for(c in 1:(C-2)){
ps = c(ps, tmp[c]-tmp[c+1])
}
ps = as.vector(c(ps, tmp[C-1]))
} else if (MODEL_NAME=="gpcm"){
tmp = c(0, tmp)
ps = as.vector(exp(tmp)/sum(exp(tmp)))
} else if (MODEL_NAME=="sequential"){
tmp = plogis(tmp)
ps = c(tmp,1)*c(1,cumprod(1-tmp))
}
pred_y = which.max(ps)
if(!is.na(test_data[i,h,j])){
test_acc = c(test_acc, pred_y==test_data[i,h,j])
if(ps[test_data[i,h,j]]<=-1e-6){
print(paste(i,"_",h,"_",j,sep=""))
}
test_ll = c(test_ll, log(1e-6+ps[test_data[i,h,j]]))
}else{
train_acc = c(train_acc, pred_y==train_data[i,h,j])
if(ps[train_data[i,h,j]]<=-1e-6){
print(paste(i,"_",h,"_",j,sep=""))
}
train_ll = c(train_ll, log(1e-6+ps[train_data[i,h,j]]))
}
}
}
}
train_acc = mean(train_acc)
train_ll = mean(train_ll[!is.na(train_ll)])
test_acc = mean(test_acc)
test_ll = mean(test_ll[!is.na(test_ll)])
save(loadings, correlation_matrix, log_lik, BIC, thetas,train_acc, train_ll,test_acc, test_ll,
file=paste("./results/synthetic/", TYPE,"_", HYP, ".RData" , sep=""))
coefs[j,2:C]
coefs
